{"version":3,"sources":["initial-data.js","task.js","column.js","validation.js","InsertSlider.js","InsertButton.js","index.js"],"names":["initialData","tasks","id","content","columns","taskIds","columnOrder","isEqSolutionCorrect","isEqSyntaxCorrect","areaSpace","isInserting","initialState","varTasks","TaskContainer","styled","div","props","isDragging","Task","draggableId","this","task","index","provided","snapshot","ref","innerRef","draggableProps","dragHandleProps","React","Component","TaskList","isDraggingOver","Column","droppableId","column","direction","droppableProps","map","key","placeholder","mathsteps","require","validate","eq","equation","msResult","steps","solveEquation","console","log","forEach","step","newEquation","ascii","changeType","InsertSlider","values","onSliderChange","onSliderChangeCommited","useState","value","setValue","style","marginTop","marginBottom","Input","margin","onChange","event","target","Number","onBlur","inputProps","min","max","type","Slider","newValue","aria-labelledby","onChangeCommitted","StyledButtonContainer","button","InsertButton","handleClick","onInsertChange","onClick","data","msg","important","window","addEventListener","preventDefault","passive","Container","Viz","Validation","prop","bgColor","Math","validateNow","newState","tasksX","taskId","join","JSON","stringify","isSyntaxCorrect","toString","isSolutionCorrect","ValidationFeedback","validation_feedback","ValidationFeedbackContainer","App","state","onDragEnd","result","document","body","color","backgroundColor","destination","source","start","finish","newTaskIds","Array","from","splice","newColumn","setState","newNewState","startTaskIds","newStart","finishTaskIds","newFinish","handleSliderChange","sliderValue","currentState","column1","table","taskTempContent","taskContent","newTask","handleInsertChange","handleSliderChangeCommitted","initialTaskValues","propertyType","designStyle","columnId","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.d007613b.chunk.js","sourcesContent":["const initialData = {\r\n  tasks: {\r\n    \"task-1\": { id: \"task-1\", content: \"x\" },\r\n    \"task-2\": { id: \"task-2\", content: \"x\" },\r\n    \"task-3\": { id: \"task-3\", content: \"55\" },\r\n    \"task-4\": { id: \"task-4\", content: \"5\" },\r\n    \"task-5\": { id: \"task-5\", content: \"+\" },\r\n    \"task-6\": { id: \"task-6\", content: \"+\" },\r\n    \"task-7\": { id: \"task-7\", content: \"=\" },\r\n    \"task-8\": { id: \"task-8\", content: \"-\" }\r\n  },\r\n  columns: {\r\n    \"column-1\": {\r\n      id: \"column-1\",\r\n      // title: 'In progress',\r\n      taskIds: []\r\n    },\r\n    \"column-2\": {\r\n      id: \"column-2\",\r\n      // title: 'To do',\r\n      taskIds: [\r\n        \"task-1\",\r\n        \"task-2\",\r\n        \"task-3\",\r\n        \"task-4\",\r\n        \"task-5\",\r\n        \"task-6\",\r\n        \"task-7\",\r\n        \"task-8\"\r\n      ]\r\n    }\r\n  },\r\n\r\n  // Facilitate reordering of the columns\r\n  columnOrder: [\"column-1\", \"column-2\"],\r\n\r\n  // default for state (mathsteps will validate equation and update this booleam)\r\n  isEqSolutionCorrect: false,\r\n  isEqSyntaxCorrect: false,\r\n\r\n  // for InsertSlider: current value\r\n  areaSpace: 20,\r\n\r\n  // for InsertButton toggling the InsertSlider\r\n  isInserting: false,\r\n\r\n  // remember the whole state when a slider starts onChange (to revert to it onChangeCommited)\r\n  initialState: null,\r\n\r\n  // varTasks: null\r\n  varTasks: {\r\n    \"task-1\": { id: \"task-1\", content: \"x\" },\r\n    \"task-2\": { id: \"task-2\", content: \"x\" }\r\n  }\r\n};\r\n\r\nexport default initialData;\r\n","import React from 'react';\r\nimport styled from 'styled-components';\r\nimport { Draggable } from 'react-beautiful-dnd';\r\n\r\n// change task bg-color (if task is dragged)\r\n// vertical-align: middle; align-items: center;\r\n//  text-align: center;\r\nconst TaskContainer = styled.div`\r\n    border: 1px solid lightgrey;\r\n    border-radius: 5px;\r\n    box-sizing: border-box; /* includes the padding and border in an element's total width and height.*/\r\n\r\n    width: 40px;\r\n    height: 40px;\r\n  \r\n    display: flex;\r\n    align-items: center;\r\n    justify-content: center;\r\n    \r\n    margin-right: 10px;\r\n      /*  distance to next item */\r\n        /* \r\n     align items vertically\r\n     align items horizontally */\r\n\r\n    background-color: ${props => (props.isDragging ? 'azure' : 'white')};\r\n\r\n    font-size: 1rem;\r\n`;\r\n\r\nexport default class Task extends React.Component {\r\n    render() {\r\n        return (\r\n            // return this.props.task.content;\r\n            <Draggable\r\n                draggableId={this.props.task.id}\r\n                index={this.props.index}>\r\n                {(provided, snapshot) => (\r\n                    <TaskContainer\r\n                        ref={provided.innerRef}\r\n                        {...provided.draggableProps}\r\n                        {...provided.dragHandleProps}\r\n                        isDragging={snapshot.isDragging}>\r\n                        {this.props.task.content}\r\n                    </TaskContainer>\r\n                )}\r\n            </Draggable>\r\n        );\r\n    }\r\n}\r\n","import React from 'react';\r\nimport styled from 'styled-components';\r\nimport {Droppable} from 'react-beautiful-dnd';\r\n\r\nimport Task from './task';\r\n\r\n// change bg-color of column (when dragging a task around) \r\nconst TaskList = styled.div`\r\n border: 1px solid grey;\r\n  border-radius: 2px;  \r\n\r\n  box-sizing: border-box; /* includes the padding and border in an element's total width and height.*/\r\n\r\n\r\n \r\n\r\n\r\n  /** for horizontal direction (of tasks within a column) */\r\n  /** NOT NEEDED, What is it for?\r\n   \r\n    flex-direction: column;\r\n  */\r\n\r\n  /** ? for horizontal direction (of tasks within a column)? */\r\n  display: flex;\r\n  align-items: center; /* align items vertically (within the container) */\r\n  justify-content: left; /* start items from left; not needed / is default */\r\n\r\n\r\n  padding-left: 10px; /* start first content (item) with some distance to container */\r\n\r\n  /** NOT USED YET flex-grow: 1; */\r\n\r\n  min-height: 60px;\r\n  /*      min-width: 365px; transition: background-color 0.2s ease; ... use all space (minus 10px from padding-left) from super container draggablecontext in index.js */\r\n  \r\n\r\n  background-color: ${props => (props.isDraggingOver ? 'grey' : 'lightgrey')};\r\n \r\n\r\n/* flex-wrap: wrap; ... replaced by: flex-direction: column; ... wraps areas to next line (if not enough space) */\r\n    /*  WORKS, NOT NEED IF flex 0 1 auto is used? (bottom) alignment along main axis; items are packed toward the end of the flex-direction. */\r\n  /* justify-content: flex-end; \r\n  align-content: flex-end; (right) how flex items are laid out along the cross axis !! DOES NOT WORK IF is wrapped !!!  */\r\n\r\n\r\n`;\r\n\r\nexport default class Column extends React.Component {\r\n  render() {\r\n    // return this.props.column.title;\r\n    return (\r\n \r\n        <Droppable droppableId={this.props.column.id} direction=\"horizontal\">  \r\n          {(provided, snapshot) =>    // unclear if after arrow function the () is needed\r\n            <TaskList\r\n              ref={provided.innerRef}\r\n              {...provided.droppableProps}\r\n              isDraggingOver={snapshot.isDraggingOver}\r\n            >\r\n              {this.props.tasks.map((task, index) => (\r\n                <Task key={task.id} task={task} index={index} />\r\n              ))}\r\n              {provided.placeholder}\r\n            </TaskList>\r\n\r\n          }\r\n        </Droppable>\r\n\r\n    );\r\n  }\r\n}","\r\n\r\n\r\n// ---- MY CODE ----\r\nconst mathsteps = require(\"mathsteps\");\r\n// const Algebrite = require(\"algebrite\");\r\n\r\n/*\r\nconst leftNode = \"x + y + 5\";\r\nconst opEquals = \" = \";\r\nconst rightNode = \"55\";\r\n\r\nconst equation = leftNode + opEquals + rightNode;\r\n*/\r\n\r\n\r\nconst validate = function val(eq) {\r\n  const equation = eq;\r\n\r\n\r\n  /** \r\n  // SIMPLIFY EXPRESSION ... not clear what it does\r\n  // const steps = mathsteps.simplifyExpression(\"x + x + 5 = 55\");\r\n \r\n const steps = mathsteps.simplifyExpression(equation);\r\n\r\n  console.log(\"SiMPLIFYEXPRESSION\");\r\n  steps.forEach(step => {\r\n    console.log(\"before change: \" + step.oldNode.toString());\r\n    console.log(\"change: \" + step.changeType);\r\n    console.log(\"number of substeps: \" + step.substeps.length);\r\n    console.log(\"after change: \" + step.newNode.toString());\r\n    console.log(\"----- next step -------\");\r\n  });\r\n*/\r\n\r\n  // msResult\r\n  // should store last step of solveQuation, e.g. x = 50\r\n  // return this variable to process in app.js and check for the 50\r\n  // if expected value, set boolean true and validation result to true\r\n  // and tell the user the solution is coreect\r\n  var msResult = \"\";  \r\n\r\n  // SOLVE EQUATION in use\r\n  const steps = mathsteps.solveEquation(equation);\r\n\r\n  console.log(\"VALIDATION: --- SOLVEEQUATION ---: equation: \" + equation);\r\n  steps.forEach(step => {\r\n    //console.log(\"before change: \" + step.oldEquation.ascii());\r\n    console.log(\r\n      step.newEquation.ascii() + \"            | operation: \" + step.changeType\r\n    );\r\n    msResult = step.newEquation.ascii();\r\n    \r\n  });\r\n  return msResult;\r\n\r\n  /** \r\n  console.log(\"SOLVEEQUATION\");\r\n  steps.forEach(step => {\r\n    console.log(\"before change: \" + step.oldEquation.ascii());\r\n    console.log(\"change: \" + step.changeType);\r\n    console.log(\"number of substeps: \" + step.substeps.length);\r\n    console.log(\"after change: \" + step.newEquation.ascii());\r\n    console.log(\"----- next step -------\");\r\n  });\r\n  */\r\n\r\n  // ALGEBRITE TESTING\r\n  // var test10 = Algebrite.eval(\"x + x + 5\").toString(); // => \"1/3 x^3\"\r\n  // SYNTAX ERROR IF equation problematic ... var test10 = Algebrite.eval(equation).toString(); // => \"1/3 x^3\"\r\n  // console.log(\"algebrite: \" + test10);\r\n\r\n  // ALGEBRITE END\r\n\r\n  // --- END OF MY CODE -----\r\n\r\n\r\n \r\n}\r\n\r\nexport default validate;\r\n","import React from \"react\";\r\nimport { Slider, Input } from \"@material-ui/core/\";\r\n\r\nexport default function InsertSlider({\r\n  values,\r\n  isInserting,\r\n  onSliderChange,\r\n  onSliderChangeCommited\r\n}) {\r\n  // console.log(\"LOG IS: values.areaSpace: \" + values.areaSpace);\r\n  const [value, setValue] = React.useState(values.areaSpace); // this value is actually never used, right?\r\n  // console.log(\"LOG IS: value: \" + value);\r\n\r\n  // if Button set Insert Mode to false, don't display the InsertSlider at all (by beforehand preventing to return it)\r\n  // NOTE: can't put this before React.useState because it doesn't allow that ...\r\n  // TODO: change it to: !props.isInserting ... ?\r\n  if (!isInserting) {\r\n    console.log(\r\n      \"INSERTSLIDER: not executing: prop isInserting: \" + isInserting\r\n    );\r\n    return null;\r\n  }\r\n  console.log(\"INSERTSLIDER: executing: prop isInserting: \" + isInserting);\r\n\r\n  const handleSliderChange = (event, newValue) => {\r\n    setValue(newValue);\r\n    console.log(\r\n      \"INSERTSLIDER | handleSliderChange: setValue(newValue): \" + newValue\r\n    );\r\n\r\n    // updating the prop onSliderChange received from index, with the new slider value\r\n    // this is a function from index.js, which was passed as a prop\r\n    onSliderChange(newValue); // must not use this.props.onSliderChange because its not a class component; also props.onSliderchange not working because function is not using { props } but individual variables instead\r\n  };\r\n\r\n  const handleSliderChangeCommitted = () => {\r\n    onSliderChangeCommited();\r\n  };\r\n\r\n  const handleInputChange = (event) => {\r\n    setValue(event.target.value === \"\" ? \"\" : Number(event.target.value));\r\n    console.log(\r\n      \"InsertSlider | LOG IS: handleInputChange: setValue(event.target.value): \" +\r\n        event.target.value\r\n    );\r\n  };\r\n\r\n  const handleBlur = () => {\r\n    if (value < 0) {\r\n      setValue(0);\r\n      console.log(\"INSERTSLIDER LOG IS: handleBlur (0)\");\r\n    } else if (value > 100) {\r\n      setValue(100);\r\n      console.log(\"INSERTSLIDER LOG IS: handleBlur (100)\");\r\n    }\r\n  };\r\n\r\n  // SLIDER\r\n  // Handle inputs change\r\n  // ?? IS THIS WORKING AT ALL? ... log never gets called?\r\n  const handleChange = (input) => (event) => {\r\n    // input is areaSpace?\r\n    // console.log(\"LOG index: handleChange: input: \" + input);  // INPUT NOT NEEDED HERE; input is only need to make handleChange generic and tell it which state var needs to be updated\r\n    // NOT IN USE yet? this.setState({ [input]: event.target.value });  // ? needed to make handleChange generic, to handle the input field?\r\n    setValue(event.target.value); // ADDED BY ME: sets the areaSpace state\r\n    console.log(\r\n      \"INSERTSLIDER: handleChange: save state setValue(): event.target.value: \" +\r\n        event.target.value\r\n    );\r\n  };\r\n\r\n  return (\r\n    <div style={{ marginTop: \"20px\", marginBottom: \"20px\" }}>\r\n      <Input\r\n        value={value}\r\n        margin=\"dense\"\r\n        onChange={handleInputChange}\r\n        onBlur={handleBlur}\r\n        inputProps={{\r\n          step: 1,\r\n          min: 0,\r\n          max: 800,\r\n          type: \"number\",\r\n          \"aria-labelledby\": \"input-slider\"\r\n        }}\r\n      />\r\n      <Slider\r\n        style={{ marginTop: \"20px\" }}\r\n        value={typeof value === \"number\" ? value : 0}\r\n        onChange={handleSliderChange}\r\n        aria-labelledby=\"input-slider\"\r\n        step={1}\r\n        min={0}\r\n        max={55}\r\n        onChangeCommitted={handleSliderChangeCommitted}\r\n      />\r\n    </div>\r\n  );\r\n}\r\n","import React from 'react';\r\nimport styled from \"styled-components\";\r\n\r\n// Styled component named StyledButton\r\nconst StyledButtonContainer = styled.button`\r\n  background-color: grey;\r\n  font-size: 1rem;\r\n  color: white;\r\n  \r\n  height: 40px;\r\n  align-content: center;\r\n  min-width: 80px;      /* override width, to give button a minimum size */\r\n  width: fit-content;   /* fit button width to text amount*/\r\n`;\r\n\r\n/*\r\n// !! PROBLEM .. does not trigger InsertSlider ... use state instead of props?\r\nvar isInserting = false; // without props, just state\r\nconst handleClick = event => {\r\nisInserting = !isInserting; // just props, without state\r\n  // const isInserting = !this.state.isInserting; // ! BUGGED\r\n\r\n  console.log(\"isInserting: \" + isInserting);\r\n  // return alert(\"isInserting: \" + isInserting);\r\nreturn (isInserting);\r\n};\r\n*/\r\n\r\n\r\n\r\n\r\n\r\nexport default class InsertButton extends React.Component {\r\n\r\n/*\r\n  constructor(props) {\r\n    super(props);\r\n    this.handleClick = this.handleClick.bind(this);\r\n    // this.state = {color: 'red'};\r\n  }\r\n*/\r\n\r\n  // !! PROBLEM .. does not trigger InsertSlider ... use state instead of props?\r\n  // var isInserting = false; // without props, just state\r\n  // handleClick = (event) => {\r\n\r\n  handleClick = (event) => {\r\n  // console.log(\"INSERTBUTTON handleClick() - props.isInserting before: \" + this.props.isInserting);\r\n  // var isInserting = this.props.isInserting;\r\n  console.log(\"INSERTBUTTON: handleClick() - isInserting before: \" + this.props.isInserting);\r\n   // isInserting = !isInserting;\r\n    var isInserting = this.props.isInserting;\r\n    console.log(\"INSERTBUTTON: handleClick() - isInserting after: \" + isInserting);\r\n    \r\n    // this.setState({ isInserting: isInserting});\r\n    this.props.onInsertChange(isInserting);\r\n    // props.setChanged();\r\n    \r\n    // console.log(\"INSERTBUTTON handleClick() - state.isInserting: \" + this.state.isInserting);\r\n    // return alert(\"isInserting: \" + isInserting);\r\n    // return (isInserting);\r\n  };\r\n\r\n\r\n  render() {\r\n      console.log(\"INSERTBUTTON: render(): this.props: isInserting: \" + this.props.isInserting);\r\n      return (\r\n          // return this.props.task.content;\r\n          // WAS BEFORE onClick={{this.handleClick}}\r\n          <StyledButtonContainer type=\"button\" onClick={this.handleClick} >Prüfen</StyledButtonContainer>\r\n      );\r\n  }\r\n}\r\n\r\n/*\r\nfunction iCouldNameThisAnything() {\r\n  // Use it like any other component.\r\n  return <StyledButton> Überprüfen </StyledButton>;\r\n}\r\n*/\r\n","import React, { Component } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { DragDropContext } from \"react-beautiful-dnd\";\nimport styled from \"styled-components\";\n\n// import styled from \"styled-components\"; // ADDED (to style <Box>)\nimport initialData from \"./initial-data\";\nimport Column from \"./column\";\nimport \"@atlaskit/css-reset\";\n\nimport validate from \"./validation\"; // import my function to validate an equation\n\nimport InsertSlider from \"./InsertSlider\";\nimport InsertButton from \"./InsertButton\";\n\n/* ---------------- LOGGING --------------------------- */\n\nconsole.data = function (msg) {\n  console.log(\n    \" % c % s % s % s\",\n    \"color: yellow; background - color: black;\",\n    \"–\",\n    msg,\n    \"–\"\n  );\n};\n\nconsole.important = function (msg) {\n  console.log(\n    \" % c % s % s % s\",\n    \"color: brown; font - weight: bold; text - decoration: underline;\",\n    \"–\",\n    msg,\n    \"–\"\n  );\n};\n\n/* ----------------------------------------------- */\n\n/* NOT IN USE\nfunction getWindowDimensions() {\n  const { innerWidth: width, innerHeight: height } = window;\n  return {\n    width,\n    height\n  };\n}\n*/\n\n// Prevents bounce on mobile browsers(when scrolling beyond top or bottom)\nwindow.addEventListener(\n  \"touchmove\",\n  function (event) {\n    event.preventDefault();\n  },\n  { passive: false }\n);\n\nconst Container = styled.div`\n  /* align-content: flex-end; (right) how flex items are laid out along the cross axis !! DOES NOT WORK IF is wrapped !!!  */\n  /* max-width: 375px; ... forces wrap (on wide screens, by limiting width */\n\n  display: flex;\n  flex-direction: column;\n  justify-content: flex-end;\n\n  height: 100%;\n  width: 100%;\n  max-width: 640px; /* TODO: define for Desktop */\n\n  background-color: white;\n\n  /* POSITION AT BOTTOM (of screen) (fills remaining space) */\n  /* (top->bottom), main-axis,  direction of flex items placement in flex container */\n  /*  WORKS, NOT NEED IF flex 0 1 auto is used? (bottom) alignment along main axis; items are packed toward the end of the flex-direction. */\n`;\n\nconst Viz = styled.div`\n  flex: 10 1 auto; /* (fills remaining space) ...  */\n  padding: 20px;\n\n  font-size: 1rem;\n`;\n\nconst Validation = styled.div`\n  flex: 1 1 auto; /* (fills remaining space) ...  */\n  /*  TRY: color: rgba(0, 0, 0, 0.5) */\n  background-color: ${(prop) => (prop.bgColor ? \"#F1FDE3\" : \"white\")};\n  padding: 20px;\n  font-size: 1rem;\n`;\n\n// const ValidationSyntax = styled.div`\n//  flex: 1 1 auto; /* (fills remaining space) ...  */\n//  background-color: ${prop => prop.bgColor ? 'lightgreen' : 'white'};\n// `\n\nconst Math = styled.div`\n  flex: 1 0 auto; /* dont grow, dont shrink, sized to content ... had it at: 0 1 200px; then 0 1 auto */\n\n  /* background-color: lightblue; */\n`;\n\n// Validate equation row\nfunction validateNow(newState) {\n  // ------- VALIDATON -----------------\n\n  // WHICH EQUATION: which COLUMN gets validated\n  // const column2 = this.state.columns['column-1'];\n  const column2 = newState.columns[\"column-1\"];\n\n  // #1 WORKS but separated ...\n  //  const tasksX = column2.taskIds.map(taskId => this.state.tasks[taskId].content); // WORKS, but ...\n\n  // #2 WORKS but separated\n  // const myList = [];\n  // const tasksX = myList.concat(column2.taskIds.map(taskId => this.state.tasks[taskId].content));\n\n  // GET EQUATION: this is the USERS EQUATION\n  const tasksX = column2.taskIds\n    .map((taskId) => newState.tasks[taskId].content)\n    .join(\"\"); // WORKS, but ...\n  console.log(\n    \"INDEX: validateNow(): PRINT STATE: current equation: tasks: \" +\n      JSON.stringify(tasksX)\n  );\n\n  // SOLVE: run mathsteps ... and get the solved result\n  const msResult = validate(tasksX); // run validation and print to console\n  console.log(\"INDEX: validateNow(): validate() result: msResult: \" + msResult);\n\n  // SYNTAX CHECK ... TODO: rudimentary implementation\n  var isSyntaxCorrect = msResult === \"\" ? false : true; // empty -> false; not empty -> true\n  console.log(\n    \"INDEX: validateNow(): isSyntaxCorrect: \" + isSyntaxCorrect.toString()\n  );\n\n  // SOLUTION CHECK ... COMPARE: check if users equation is correct\n  // -> compare mathsteps result with hardcoed result\n  // var isSolutionCorrect = (msResult === (\"x = 25\"));\n  // DOES NOT WORK FOR 30 ... var isSolutionCorrect = (msResult.localeCompare(\"x = 25\" || \"x = 30\") ); // NOT WORKING CORRECTLY\n  // DOES NOT WORK AT ALL var isSolutionCorrect = (msResult === (\"x = 25\") || (\"x = 30\") );\n  var isSolutionCorrect = false;\n  if (msResult === \"x = 25\") {\n    isSolutionCorrect = true;\n  }\n  if (msResult === \"x = 30\") {\n    isSolutionCorrect = true;\n  }\n  console.log(\n    \"INDEX: validateNow(): isSolutionCorrect: \" + isSolutionCorrect.toString()\n  );\n\n  // UPDATE: show the user if his equation correct\n  // -> update variable which gets display to user\n  // this.setState({isEqSolutionCorrect: check});\n\n  const newNewState = {\n    // make sure all other state entries stay there\n    ...newState,\n    columns: {\n      ...newState.columns\n      // [newStart.id]: newStart,\n      // [newFinish.id]: newFinish,\n    },\n    isEqSolutionCorrect: isSolutionCorrect, // change state again with validation result isCorrect\n    isEqSyntaxCorrect: isSyntaxCorrect\n  };\n\n  return newNewState;\n}\n\n// const SOL_WRONG = \"❓\";\n// const SOL_CORRECT = '😍';\n\nfunction ValidationFeedback(props) {\n  const SOLUTION_WRONG = \"❓\";\n  const SOLUTION_CORRECT = \"😍\";\n  const SYNTAX_CORRECT = \"🌱\";\n\n  console.log(\n    \"INDEX: ValidationFeedback: props.isSolutionCorrect: \" +\n      props.isSolutionCorrect\n  );\n\n  var validation_feedback = SOLUTION_WRONG;\n  if (props.isSyntaxCorrect) {\n    validation_feedback = SYNTAX_CORRECT;\n  }\n  if (props.isSolutionCorrect) {\n    validation_feedback = SOLUTION_CORRECT;\n  }\n  // props.isSyntaxCorrect ? SYNTAX_CORRECT : SOLUTION_WRONG;\n  // const validation_feedback = props.isSolutionCorrect ? SOLUTION_CORRECT : SOLUTION_WRONG;\n  console.log(\n    \"INDEX: ValidationFeedback: validation_feedback: \" + validation_feedback\n  );\n\n  return validation_feedback;\n}\n\nclass ValidationFeedbackContainer extends Component {\n  /*\n  constructor(props) {\n    super(props);\n   \n  }\n*/\n\n  // NEVER USED\n  // const SOLUTION_CORRECT = '😍';\n\n  // prop => prop.isSolutionCorrect\n  // prop => prop.isSyntaxCorrect\n\n  // const validation_feedback = SOLUTION_WRONG;\n\n  render() {\n    return (\n      <ValidationFeedback\n        isSolutionCorrect={this.props.isSolutionCorrect}\n        isSyntaxCorrect={this.props.isSyntaxCorrect}\n      >\n        test {this.validation_feedback}\n      </ValidationFeedback>\n    );\n  }\n}\n\n/*\nconst ValidationFeedback = styled.div`\n  font-size: 1rem;\n`\n*/\n\n// console.log(\"LOG \" + SOLUTION_WRONG + \" \" + SOLUTION_CORRECT);\n\nclass App extends Component {\n  state = initialData;\n\n  onDragEnd = (result) => {\n    console.log(\"INDEX: onDragEnd(): --------- dragging ------------\");\n    document.body.style.color = \"inherit\";\n    document.body.style.backgroundColor = \"inherit\";\n\n    const { destination, source, draggableId } = result;\n\n    // #1 OUTSIDE: if dropped outside of boundary (put back to source position) ?\n    if (!destination) {\n      return; // do nothing\n    }\n\n    // #2 SAME: if dropped on same spot ?\n    if (\n      destination.droppableId === source.droppableId &&\n      destination.index === source.index\n    ) {\n      return; // do nothing\n    }\n\n    const start = this.state.columns[source.droppableId];\n    const finish = this.state.columns[destination.droppableId];\n\n    // #3 SAME ROW: if dropped within same column ?\n    if (start === finish) {\n      const newTaskIds = Array.from(start.taskIds);\n      newTaskIds.splice(source.index, 1);\n      newTaskIds.splice(destination.index, 0, draggableId);\n\n      const newColumn = {\n        ...finish,\n        taskIds: newTaskIds\n      };\n\n      const newState = {\n        ...this.state,\n        columns: {\n          ...this.state.columns,\n          [newColumn.id]: newColumn\n        }\n      };\n\n      this.setState(newState); // update state with new order of items\n\n      // ------- VALIDATON -----------------\n      const newNewState = validateNow(newState); // validate the new state with mathsteps\n      this.setState(newNewState); // update state\n      // ------- END of VALIDATON -----------------\n\n      console.log(\n        \"INDEX: onDragEnd(): --------- finished dragging (within row) ------------\"\n      );\n\n      return;\n    }\n\n    // #4 OTHER ROW: Moving from one list to another\n    const startTaskIds = Array.from(start.taskIds);\n    startTaskIds.splice(source.index, 1);\n    const newStart = {\n      ...start,\n      taskIds: startTaskIds\n    };\n\n    const finishTaskIds = Array.from(finish.taskIds);\n    finishTaskIds.splice(destination.index, 0, draggableId);\n    const newFinish = {\n      ...finish,\n      taskIds: finishTaskIds\n    };\n\n    const newState = {\n      ...this.state,\n      columns: {\n        ...this.state.columns,\n        [newStart.id]: newStart,\n        [newFinish.id]: newFinish\n      }\n    };\n    this.setState(newState);\n\n    // ------- VALIDATON -----------------\n    const newNewState = validateNow(newState); // validate the new state with mathsteps\n    this.setState(newNewState); // update state\n    // ------- END of VALIDATON -----------------\n\n    // TODO ?? MAKE THIS WORK FOR ALL TASK MOVMENTS, NOT JUST #4\n    // MOVED, NOT NEEDED ANYMORE\n    // this.setState({ initialState: this.state });\n\n    console.log(\n      \"INDEX: onDragEnd(): --------- finished dragging (to other row) ------------\"\n    );\n  };\n\n  // CURRENTLY HARDCODED IN INITIAL-DATA\n  // SET VARTASKS\n  // set varTasks in state (once for a whole session, because the \"x\" variables stay the same across the session)\n  /*\n      var column1 = this.state.columns['column-1'];\n      var taskIds = column1.taskIds;\n      taskIds.map(taskId => {\n        var task = this.state.tasks[taskId];\n        var taskContent = this.state.tasks[taskId].content;\n        if (taskContent === \"x\") { \n          this.setState({\n            varTasks: [...this.state.varTasks, task]\n          })\n        }\n      }\n      */\n\n  // update variables with slider value, while dragging slider, if \"Prüfen\" is activated\n  handleSliderChange = (sliderValue) => {\n    console.log(\"INDEX: handleSliderChange(): sliderValue: \" + sliderValue);\n\n    // remember which tasks contained an \"x\",\n    // because the current state will be overwritten with the slider value multiple times\n\n    var initialState = this.state.initialState;\n    /*\n      if (initialState == null) {\n        this.setState({ initialState: this.state });\n        console.log(\"INITIALSTATE was null\");\n        console.log(\"+++ INITIALSTATE: \" + JSON.stringify(initialState, null, 2));\n      } else {\n        console.log(\"INITIALSTATE WAS SET\");\n        console.log(\"+++ INITIALSTATE: \" + JSON.stringify(initialState, null, 2));\n      }\n     */\n\n    // --- 1. GET THE TASKIDS THAT I NEED from the current state-----\n\n    var currentState = this.state;\n\n    var column1 = currentState.columns[\"column-1\"]; // .taskIds DOES NOT WORK, WHY?\n    console.log(\"--- COLUMN1: \" + JSON.stringify(column1)); // works {\"id\":\"column-1\",\"taskIds\":[\"task-1\",\"task-3\"]}\n    var taskIds = column1.taskIds;\n    console.log(\"--- TASKIDS: \" + JSON.stringify(taskIds)); // [\"task-1\",\"task-3\"]\n\n    // DEBUG: Show my each taskId from the taskIds of currentState (to make sure they are read correctly)\n    taskIds.map((taskId) => {\n      console.log(\"--- DEBUG TASKid: \" + taskId); // works: task-1      task-3\n      return taskId; // NEEDED in arrow function; BUT NOT USED ??\n    });\n\n    console.table(taskIds);\n\n    // DEBUG: Show my each content of the taskId from the taskIds of currentState (to make sure they are read correctly)\n    taskIds.map((taskId) => {\n      var taskTempContent = this.state.tasks[taskId].content;\n      console.log(\n        \"+++ DEBUG TASKTEMPCONTENT: \" + JSON.stringify(taskTempContent)\n      );\n      return taskId; // NEEDED in arrow function; BUT NOT USED ??\n    });\n\n    // --- 2. LOOK IN ALL TASKS - for these tasks -----\n    var newState = null;\n\n    var varTasks = this.state.varTasks;\n\n    // var tasks = this.state.tasks;\n    // var taskContent = tasks[taskId].content;\n\n    // WORKS AND CAN MATCH ... BUT HOW TO ACCESS .content and replace it ??\n    taskIds.map((taskId) => {\n      // var taskContent = initialState.tasks[taskId].content; // ORIGINAL version which produces initialState ... null ERROR\n      var taskContent = this.state.tasks[taskId].content; // ISSUE: WORKS WITHOUT ERROR - but after 2nd commited, it does not updates&reset the x (value)\n      console.log(\"+++ cur TASKCONTENT: \" + JSON.stringify(taskContent));\n\n      // var Task = this.state.varTasks[taskId];\n\n      // varTasks.map(id => {\n      //  if (id === taskId) {\n      if (taskId === \"task-1\" || taskId === \"task-2\") {\n        const newTask = {\n          ...currentState.tasks[taskId],\n          // content: sliderValue,     // ! update task content with current slider value (content is treated as string, sliderValue as variable)\n          content: JSON.stringify(sliderValue, null, 2) // ! update task content with current slider value (content is treated as string, sliderValue as variable)\n        };\n        console.log(\"+++ found x! NEWTASK: \" + JSON.stringify(newTask));\n\n        // TODO: REPLACE EXISTING TASK, not just add a new one with same id\n\n        // combine all tasks that should be updated into 1 setState()? outside of map\n        newState = {\n          ...this.state, // replace with currentState?\n          tasks: {\n            ...this.state.tasks,\n            [taskId]: newTask\n          }\n        };\n        // log whole state\n        console.log(\"+++ NEWSTATE: \" + JSON.stringify(newState, null, 2));\n\n        // ?rem? TEMP 14.05.         this.setState(newState);    // update state with new order of items\n      } else {\n        console.log(\"INDEX REPLACE: else: did not replace: \" + taskId);\n\n        // TRIES\n        // Removed because .. i don't know, maybe put it in again\n        // add 14.05.\n        newState = this.state;\n      }\n\n      this.setState(newState); // update state with new order of items\n\n      //        return id; // REFACTOR: NEEDED in arrow function; BUT NOT USED ??\n      //      }); // end of varTasks.map\n\n      return taskId;\n    }); // end of taskIds.map\n  }; // end of handleSliderChange\n\n  /*\n        // TODO: replace only where content is \"x\"\n        // WORKS BUT ONLY THE FIRST TIME; Further: x -> 16 -> no replacement\n          // REMEMBER INITIAL STATE and reset to x\n          // END WITH PRÜFEN ENDE (works?)\n         if (taskContent === \"x\") {\n\n          const newTask = {\n            ...currentState.tasks[taskId],\n            // content: sliderValue,     // ! update task content with current slider value (content is treated as string, sliderValue as variable)\n            content: JSON.stringify(sliderValue, null, 2),     // ! update task content with current slider value (content is treated as string, sliderValue as variable)\n          };\n          console.log(\"+++ found x! NEWTASK: \" + JSON.stringify(newTask));\n  \n          // TODO: REPLACE EXISTING TASK, not just add a new one with same id\n  \n          // combine all tasks that should be updated into 1 setState()? outside of map\n          newState = {\n            ...this.state,  // replace with currentState?\n            tasks: {\n            ...this.state.tasks,\n              [taskId]: newTask,\n            },\n          };\n          // log whole state\n          console.log(\"+++ NEWSTATE: \" + JSON.stringify(newState, null, 2));\n\n// ?rem? TEMP 14.05.         this.setState(newState);    // update state with new order of items\n      \n           \n         } else {\n            console.log(\"INDEX REPLACE: else: did not replace: \" + taskId);\n            \n            // TRIES\n            // Removed because .. i don't know, maybe put it in again\n // add 14.05.     \n            newState = this.state;\n         }\n\n           \n          // TODO PUT THIS OUTSIDE OF the map function for performance;\n          // but need to bundle all newTask 's into one update; \n          // else just the last one will be updated\n          // TRIES outside of if/else\n // add TEMP 14.05.      \n          this.setState(newState);    // update state with new order of items\n \n\n  \n        return taskId; // REFACTOR: NEEDED in arrow function; BUT NOT USED ??\n      });\n \n      \n  \n          \n        // REPLACE\n        // var tasksStringified = JSON.stringify(tasks);\n        // tasksStringified = tasksStringified.replace('\"content\": \"x\"', '\"content\": \"a\"');\n        \n\n \n\n      // TODO: setState (with new tasks)\n    }\n*/\n\n  // INSERTBUTTON\n  // Function to set the parent's state\n  handleInsertChange = (isInserting) => {\n    console.log(\n      \"INDEX: handleInsertChange(): before isInserting: \" + isInserting\n    );\n    // var reversedInsert = !isInserting;\n    isInserting = !isInserting;\n    console.log(\n      \"INDEX: handleInsertChange(): after isInserting: \" + isInserting\n    );\n\n    // UPDATE ISINSERTING: switch the boolean when \"Prüfen\" is clicked\n    // this.setState({ isInserting: isInserting });\n    console.log(\n      \"INDEX: handleInsertChange(): before setState() isInserting: \" +\n        this.state.isInserting\n    );\n    this.setState((state, isInserting) => ({\n      // isInserting: isInserting // has the [object Object] problem?\n      isInserting: !state.isInserting // can remove the isInserting stuff above?\n    }));\n    // not correct? why? setState done asynchronously? or smthg else?\n    console.log(\n      \"INDEX: handleInsertChange(): state.isInserting: \" +\n        this.state.isInserting\n    );\n\n    // SAVE INITIAL STATE for handleSliderChange\n    // for updating task content, if slider is moved\n    // remember current state, so thtat it can be reverted onChangeCommitted\n    // TODO: make this more robust\n    if (isInserting) {\n      // if (this.state.initialState == null) {\n      // this.setState({ initialState: this.state });\n      this.setState((state) => ({\n        initialState: state\n      }));\n\n      console.log(\"+++ this.state: \" + JSON.stringify(this.state, null, 2));\n      console.log(\"SAVED INITIALSTATE SNAPSHOT\");\n    }\n\n    // UPDATE ITEMS/TASKS labels if isInserting\n    /*     \n      // only if isInserting\n      if (isInserting) {\n        \n        // First: get areaSpace ... either from state or pros\n        const areaSpace = this.state.areaSpace;\n\n        // Second: get items of column 1\n        const columnId = 1;\n        \n        // TODO only if column 1 is not empty\n        // iterate through tasks and look for \"x\" value; \n        // replace each \"x\" with areaChange\n        const column = this.state.columns[columnId];\n        const newTasks = column.taskIds.map(taskId => \n          // this.state.tasks[taskId];\n          if (this.state.tasks[taskId].contains(\"x\")) {\n            this.state.tasks[taskId].replace(areaSpace);\n          } else {\n            this.state.tasks[taskId];\n          }\n        );\n        // setState( ... newTasks)\n      \n\n    \n      \n        // // return column.title;\n        //  return <Column key={column.id} column={column} tasks={tasks} />;\n      } else if (!isInserting) {\n        // replace the current with the original\n      } else {\n        console.log(\"INDEX: WARNING!!! - SHOULD NEVER HAPPEN\");\n      }\n*/\n    // if isInserting (better: dragging) update tasks with content \"x\" to current slider value\n  };\n\n  handleSliderChangeCommitted = (initialTaskValues) => {\n    /*\n      console.log(\"HANDLESLIDERCHANGECOMMITED: trying to reset initialState, get ready ...\");\n      \n      // take from current state the remembered original state from initialState and write initialState into current state\n      const initialStateUpdated = this.state.initialState;  // ADDED TRYING TO FIX A PROBLEM with intialState is null\n      console.log(\"HANDLESLIDERCHANGECOMMITED: this should be the origianl initialState \" + JSON.stringify(initialStateUpdated, null, 2));\n      \n      // USED SOFFAR this.setState(this.state.initialState);  // revert state to state with initial values after slider use\n      this.setState(initialStateUpdated);  // revert state to state with initial values after slider use\n\n\n      // DEBUG: check if current State is really the original initialState\n      console.log(\"HANDLESLIDERCHANGECOMMITED: this is the new state and should be the origianl initialState \" + JSON.stringify(this.state, null, 2));\n\n      // this.setState({ initialState: null }); // reset after slider use\n      console.log(\"HANDLESLIDERCHANGECOMMITED: reset initialState ... at least tried - END\");\n      \n    */\n\n    // RESET TO \"X\" (hardcoded)\n    // to reset content of task-1 and task-2 back to \"x\"\n    // COPIED FROM handleSliderChange\n\n    const origVarValue = \"x\";\n\n    var currentState = this.state;\n    var column1 = currentState.columns[\"column-1\"]; // .taskIds DOES NOT WORK, WHY?\n    var taskIds = column1.taskIds;\n\n    var newState = null;\n\n    taskIds.map((taskId) => {\n      if (taskId === \"task-1\" || taskId === \"task-2\") {\n        const newTask = {\n          ...currentState.tasks[taskId],\n\n          // content: JSON.stringify(origVarValue, null, 2),     // ! update task content with current slider value (content is treated as string, sliderValue as variable)\n          content: origVarValue\n        };\n\n        newState = {\n          ...this.state, // replace with currentState?\n          tasks: {\n            ...this.state.tasks,\n            [taskId]: newTask\n          }\n        };\n      } else {\n        console.log(\"INDEX REPLACE: else: did not replace: \" + taskId);\n\n        newState = this.state;\n      }\n\n      this.setState(newState); // update state with new order of items\n\n      return taskId;\n    }); // end of taskIds.map\n  };\n\n  render() {\n    // console.log(\"getWindowDimentions(): \" + JSON.stringify(getWindowDimensions()) );\n\n    // DEBUG: NOT NEEDED ANYMORE\n    // console.log(\"LOG isEqSyntaxCorrect: \" + this.state.isEqSyntaxCorrect.toString()); // TODO: updates 1 run too late!\n    // console.log(\"LOG isEqSolutionCorrect: \" + this.state.isEqSolutionCorrect.toString()); // TODO: updates 1 run too late!\n\n    console.log(\"INDEX: render(): ------- RENDER-START ------------- \");\n\n    // SLIDER\n    const { propertyType, areaSpace, designStyle } = this.state; // take those three items from state and put them into the const values and hand it to the slider - but just areaspace will be used (see InsertSlider.js)\n    console.log(\"INDEX: render(): this.state default: areaSpace: \" + areaSpace);\n    const values = { propertyType, areaSpace, designStyle }; // for InsertSlider\n\n    // INSERTBUTTON\n    // const { isInserting } = this.state;\n    console.log(\n      \"INDEX: render(): this.state default: isInserting: \" +\n        this.state.isInserting\n    );\n\n    return (\n      <DragDropContext onDragEnd={this.onDragEnd}>\n        <Container>\n          <Viz>\n            Die Hunde Sammy und Carla wiegen zusammen 55kg. Carla wiegt um 5kg\n            mehr als Sammy.\n            <br />\n            <br /> Wie schwer sind die Hunde?\n          </Viz>\n          {\n            // TODO: put into Validation tag: isCorrectSolution={isCorrect}, isCorrectSyntax={isCorrectSyntax}\n            // <ValidationSyntax bgColor={this.state.isEqSyntaxCorrect}>Gültige Gleichung: {this.state.isEqSyntaxCorrect.toString()} </ValidationSyntax>\n            // Validation: {this.state.isEqSolutionCorrect.toString()}\n          }\n          <Validation bgColor={this.state.isEqSolutionCorrect}>\n            Korrekte Lösung:{\" \"}\n            {\n              //this.state.isEqSolutionCorrect ? SOL_CORRECT : SOL_WRONG\n            }\n            <ValidationFeedbackContainer\n              isSolutionCorrect={this.state.isEqSolutionCorrect}\n              isSyntaxCorrect={this.state.isEqSyntaxCorrect}\n            ></ValidationFeedbackContainer>\n          </Validation>\n          <InsertButton\n            isInserting={this.state.isInserting}\n            onInsertChange={this.handleInsertChange}\n          ></InsertButton>\n          <Math>\n            {this.state.columnOrder.map((columnId) => {\n              const column = this.state.columns[columnId];\n              const tasks = column.taskIds.map(\n                (taskId) => this.state.tasks[taskId]\n              );\n\n              // return column.title;\n              return <Column key={column.id} column={column} tasks={tasks} />;\n            })}\n          </Math>\n          {\n            // InsertSlider => isInserting  ? display InsertSlider : not\n\n            <InsertSlider\n              values={values}\n              onSliderChange={this.handleSliderChange} // pass the index: onSliderChange function as prop to InsertSlider; there InsertSlider updates in handleSliderChange? the prop sliderValue, which can be used in index to update labels in tasks\n              onSliderChangeCommited={this.handleSliderChangeCommitted}\n              style={{ marginTop: \"20px\", marginBottom: \"20px\" }}\n              isInserting={this.state.isInserting}\n            />\n          }\n        </Container>\n      </DragDropContext>\n    );\n  }\n}\n\n// Put the things into the DOM!\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}